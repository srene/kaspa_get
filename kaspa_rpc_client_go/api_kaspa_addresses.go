/*
Kaspa REST-API server

This server is to communicate with kaspa network via REST-API

API version: tbd
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// KaspaAddressesAPIService KaspaAddressesAPI service
type KaspaAddressesAPIService service

type ApiGetAddressesActiveAddressesActivePostRequest struct {
	ctx context.Context
	ApiService *KaspaAddressesAPIService
	addressesActiveRequest *AddressesActiveRequest
}

func (r ApiGetAddressesActiveAddressesActivePostRequest) AddressesActiveRequest(addressesActiveRequest AddressesActiveRequest) ApiGetAddressesActiveAddressesActivePostRequest {
	r.addressesActiveRequest = &addressesActiveRequest
	return r
}

func (r ApiGetAddressesActiveAddressesActivePostRequest) Execute() ([]TxIdResponse, *http.Response, error) {
	return r.ApiService.GetAddressesActiveAddressesActivePostExecute(r)
}

/*
GetAddressesActiveAddressesActivePost Get Addresses Active

This endpoint checks if addresses have had any transaction activity in the past.
It is specifically designed for HD Wallets to verify historical address activity.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAddressesActiveAddressesActivePostRequest
*/
func (a *KaspaAddressesAPIService) GetAddressesActiveAddressesActivePost(ctx context.Context) ApiGetAddressesActiveAddressesActivePostRequest {
	return ApiGetAddressesActiveAddressesActivePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TxIdResponse
func (a *KaspaAddressesAPIService) GetAddressesActiveAddressesActivePostExecute(r ApiGetAddressesActiveAddressesActivePostRequest) ([]TxIdResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TxIdResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaAddressesAPIService.GetAddressesActiveAddressesActivePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addresses/active"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.addressesActiveRequest == nil {
		return localVarReturnValue, nil, reportError("addressesActiveRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.addressesActiveRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBalanceFromKaspaAddressAddressesKaspaAddressBalanceGetRequest struct {
	ctx context.Context
	ApiService *KaspaAddressesAPIService
	kaspaAddress string
}

func (r ApiGetBalanceFromKaspaAddressAddressesKaspaAddressBalanceGetRequest) Execute() (*BalanceResponse, *http.Response, error) {
	return r.ApiService.GetBalanceFromKaspaAddressAddressesKaspaAddressBalanceGetExecute(r)
}

/*
GetBalanceFromKaspaAddressAddressesKaspaAddressBalanceGet Get Balance From Kaspa Address

Get balance for a given kaspa address

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param kaspaAddress Kaspa address as string e.g. kaspatest:qpqz2vxj23kvh0m73ta2jjn2u4cv4tlufqns2eap8mxyyt0rvrxy6ejkful67
 @return ApiGetBalanceFromKaspaAddressAddressesKaspaAddressBalanceGetRequest
*/
func (a *KaspaAddressesAPIService) GetBalanceFromKaspaAddressAddressesKaspaAddressBalanceGet(ctx context.Context, kaspaAddress string) ApiGetBalanceFromKaspaAddressAddressesKaspaAddressBalanceGetRequest {
	return ApiGetBalanceFromKaspaAddressAddressesKaspaAddressBalanceGetRequest{
		ApiService: a,
		ctx: ctx,
		kaspaAddress: kaspaAddress,
	}
}

// Execute executes the request
//  @return BalanceResponse
func (a *KaspaAddressesAPIService) GetBalanceFromKaspaAddressAddressesKaspaAddressBalanceGetExecute(r ApiGetBalanceFromKaspaAddressAddressesKaspaAddressBalanceGetRequest) (*BalanceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BalanceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaAddressesAPIService.GetBalanceFromKaspaAddressAddressesKaspaAddressBalanceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addresses/{kaspaAddress}/balance"
	localVarPath = strings.Replace(localVarPath, "{"+"kaspaAddress"+"}", url.PathEscape(parameterValueToString(r.kaspaAddress, "kaspaAddress")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBalancesFromKaspaAddressesAddressesBalancesPostRequest struct {
	ctx context.Context
	ApiService *KaspaAddressesAPIService
	balanceRequest *BalanceRequest
}

func (r ApiGetBalancesFromKaspaAddressesAddressesBalancesPostRequest) BalanceRequest(balanceRequest BalanceRequest) ApiGetBalancesFromKaspaAddressesAddressesBalancesPostRequest {
	r.balanceRequest = &balanceRequest
	return r
}

func (r ApiGetBalancesFromKaspaAddressesAddressesBalancesPostRequest) Execute() ([]BalancesByAddressEntry, *http.Response, error) {
	return r.ApiService.GetBalancesFromKaspaAddressesAddressesBalancesPostExecute(r)
}

/*
GetBalancesFromKaspaAddressesAddressesBalancesPost Get Balances From Kaspa Addresses

Get balance for a given kaspa address

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBalancesFromKaspaAddressesAddressesBalancesPostRequest
*/
func (a *KaspaAddressesAPIService) GetBalancesFromKaspaAddressesAddressesBalancesPost(ctx context.Context) ApiGetBalancesFromKaspaAddressesAddressesBalancesPostRequest {
	return ApiGetBalancesFromKaspaAddressesAddressesBalancesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []BalancesByAddressEntry
func (a *KaspaAddressesAPIService) GetBalancesFromKaspaAddressesAddressesBalancesPostExecute(r ApiGetBalancesFromKaspaAddressesAddressesBalancesPostRequest) ([]BalancesByAddressEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []BalancesByAddressEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaAddressesAPIService.GetBalancesFromKaspaAddressesAddressesBalancesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addresses/balances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.balanceRequest == nil {
		return localVarReturnValue, nil, reportError("balanceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.balanceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFullTransactionsForAddressAddressesKaspaAddressFullTransactionsGetRequest struct {
	ctx context.Context
	ApiService *KaspaAddressesAPIService
	kaspaAddress string
	limit *int32
	offset *int32
	fields *string
	resolvePreviousOutpoints *EndpointsGetAddressTransactionsPreviousOutpointLookupMode
}

// The number of records to get
func (r ApiGetFullTransactionsForAddressAddressesKaspaAddressFullTransactionsGetRequest) Limit(limit int32) ApiGetFullTransactionsForAddressAddressesKaspaAddressFullTransactionsGetRequest {
	r.limit = &limit
	return r
}

// The offset from which to get records
func (r ApiGetFullTransactionsForAddressAddressesKaspaAddressFullTransactionsGetRequest) Offset(offset int32) ApiGetFullTransactionsForAddressAddressesKaspaAddressFullTransactionsGetRequest {
	r.offset = &offset
	return r
}

func (r ApiGetFullTransactionsForAddressAddressesKaspaAddressFullTransactionsGetRequest) Fields(fields string) ApiGetFullTransactionsForAddressAddressesKaspaAddressFullTransactionsGetRequest {
	r.fields = &fields
	return r
}

// Use this parameter if you want to fetch the TransactionInput previous outpoint details. Light fetches only the adress and amount. Full fetches the whole TransactionOutput and adds it into each TxInput.
func (r ApiGetFullTransactionsForAddressAddressesKaspaAddressFullTransactionsGetRequest) ResolvePreviousOutpoints(resolvePreviousOutpoints EndpointsGetAddressTransactionsPreviousOutpointLookupMode) ApiGetFullTransactionsForAddressAddressesKaspaAddressFullTransactionsGetRequest {
	r.resolvePreviousOutpoints = &resolvePreviousOutpoints
	return r
}

func (r ApiGetFullTransactionsForAddressAddressesKaspaAddressFullTransactionsGetRequest) Execute() ([]TxModel, *http.Response, error) {
	return r.ApiService.GetFullTransactionsForAddressAddressesKaspaAddressFullTransactionsGetExecute(r)
}

/*
GetFullTransactionsForAddressAddressesKaspaAddressFullTransactionsGet Get Full Transactions For Address

DEPRECATED, ONLY RETURNS THE FIRST PAGE

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param kaspaAddress Kaspa address as string e.g. kaspatest:qpqz2vxj23kvh0m73ta2jjn2u4cv4tlufqns2eap8mxyyt0rvrxy6ejkful67
 @return ApiGetFullTransactionsForAddressAddressesKaspaAddressFullTransactionsGetRequest
*/
func (a *KaspaAddressesAPIService) GetFullTransactionsForAddressAddressesKaspaAddressFullTransactionsGet(ctx context.Context, kaspaAddress string) ApiGetFullTransactionsForAddressAddressesKaspaAddressFullTransactionsGetRequest {
	return ApiGetFullTransactionsForAddressAddressesKaspaAddressFullTransactionsGetRequest{
		ApiService: a,
		ctx: ctx,
		kaspaAddress: kaspaAddress,
	}
}

// Execute executes the request
//  @return []TxModel
func (a *KaspaAddressesAPIService) GetFullTransactionsForAddressAddressesKaspaAddressFullTransactionsGetExecute(r ApiGetFullTransactionsForAddressAddressesKaspaAddressFullTransactionsGetRequest) ([]TxModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TxModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaAddressesAPIService.GetFullTransactionsForAddressAddressesKaspaAddressFullTransactionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addresses/{kaspaAddress}/full-transactions"
	localVarPath = strings.Replace(localVarPath, "{"+"kaspaAddress"+"}", url.PathEscape(parameterValueToString(r.kaspaAddress, "kaspaAddress")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
		var defaultValue int32 = 0
		r.offset = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	} else {
		var defaultValue string = ""
		r.fields = &defaultValue
	}
	if r.resolvePreviousOutpoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resolve_previous_outpoints", r.resolvePreviousOutpoints, "form", "")
	} else {
		var defaultValue EndpointsGetAddressTransactionsPreviousOutpointLookupMode = "no"
		r.resolvePreviousOutpoints = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGetRequest struct {
	ctx context.Context
	ApiService *KaspaAddressesAPIService
	kaspaAddress string
	limit *int32
	before *int32
	after *int32
	fields *string
	resolvePreviousOutpoints *EndpointsGetAddressTransactionsPreviousOutpointLookupMode
}

// The max number of records to get. For paging combine with using &#39;before/after&#39; from oldest previous result. Use value of X-Next-Page-Before/-After as long as header is present to continue paging. The actual number of transactions returned for each page can be &gt; limit.
func (r ApiGetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGetRequest) Limit(limit int32) ApiGetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGetRequest {
	r.limit = &limit
	return r
}

// Only include transactions with block time before this (epoch-millis)
func (r ApiGetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGetRequest) Before(before int32) ApiGetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGetRequest {
	r.before = &before
	return r
}

// Only include transactions with block time after this (epoch-millis)
func (r ApiGetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGetRequest) After(after int32) ApiGetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGetRequest {
	r.after = &after
	return r
}

func (r ApiGetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGetRequest) Fields(fields string) ApiGetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGetRequest {
	r.fields = &fields
	return r
}

// Use this parameter if you want to fetch the TransactionInput previous outpoint details. Light fetches only the adress and amount. Full fetches the whole TransactionOutput and adds it into each TxInput.
func (r ApiGetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGetRequest) ResolvePreviousOutpoints(resolvePreviousOutpoints EndpointsGetAddressTransactionsPreviousOutpointLookupMode) ApiGetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGetRequest {
	r.resolvePreviousOutpoints = &resolvePreviousOutpoints
	return r
}

func (r ApiGetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGetRequest) Execute() ([]TxModel, *http.Response, error) {
	return r.ApiService.GetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGetExecute(r)
}

/*
GetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGet Get Full Transactions For Address Page

Get all transactions for a given address from database.
And then get their related full transaction data

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param kaspaAddress Kaspa address as string e.g. kaspatest:qpqz2vxj23kvh0m73ta2jjn2u4cv4tlufqns2eap8mxyyt0rvrxy6ejkful67
 @return ApiGetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGetRequest
*/
func (a *KaspaAddressesAPIService) GetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGet(ctx context.Context, kaspaAddress string) ApiGetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGetRequest {
	return ApiGetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGetRequest{
		ApiService: a,
		ctx: ctx,
		kaspaAddress: kaspaAddress,
	}
}

// Execute executes the request
//  @return []TxModel
func (a *KaspaAddressesAPIService) GetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGetExecute(r ApiGetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGetRequest) ([]TxModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TxModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaAddressesAPIService.GetFullTransactionsForAddressPageAddressesKaspaAddressFullTransactionsPageGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addresses/{kaspaAddress}/full-transactions-page"
	localVarPath = strings.Replace(localVarPath, "{"+"kaspaAddress"+"}", url.PathEscape(parameterValueToString(r.kaspaAddress, "kaspaAddress")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		r.limit = &defaultValue
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	} else {
		var defaultValue int32 = 0
		r.before = &defaultValue
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	} else {
		var defaultValue int32 = 0
		r.after = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	} else {
		var defaultValue string = ""
		r.fields = &defaultValue
	}
	if r.resolvePreviousOutpoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resolve_previous_outpoints", r.resolvePreviousOutpoints, "form", "")
	} else {
		var defaultValue EndpointsGetAddressTransactionsPreviousOutpointLookupMode = "no"
		r.resolvePreviousOutpoints = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNameForAddressAddressesKaspaAddressNameGetRequest struct {
	ctx context.Context
	ApiService *KaspaAddressesAPIService
	kaspaAddress string
}

func (r ApiGetNameForAddressAddressesKaspaAddressNameGetRequest) Execute() (*AddressName, *http.Response, error) {
	return r.ApiService.GetNameForAddressAddressesKaspaAddressNameGetExecute(r)
}

/*
GetNameForAddressAddressesKaspaAddressNameGet Get Name For Address

Get the name for an address

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param kaspaAddress Kaspa address as string e.g. kaspa:qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqkx9awp4e
 @return ApiGetNameForAddressAddressesKaspaAddressNameGetRequest
*/
func (a *KaspaAddressesAPIService) GetNameForAddressAddressesKaspaAddressNameGet(ctx context.Context, kaspaAddress string) ApiGetNameForAddressAddressesKaspaAddressNameGetRequest {
	return ApiGetNameForAddressAddressesKaspaAddressNameGetRequest{
		ApiService: a,
		ctx: ctx,
		kaspaAddress: kaspaAddress,
	}
}

// Execute executes the request
//  @return AddressName
func (a *KaspaAddressesAPIService) GetNameForAddressAddressesKaspaAddressNameGetExecute(r ApiGetNameForAddressAddressesKaspaAddressNameGetRequest) (*AddressName, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AddressName
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaAddressesAPIService.GetNameForAddressAddressesKaspaAddressNameGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addresses/{kaspaAddress}/name"
	localVarPath = strings.Replace(localVarPath, "{"+"kaspaAddress"+"}", url.PathEscape(parameterValueToString(r.kaspaAddress, "kaspaAddress")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionCountForAddressAddressesKaspaAddressTransactionsCountGetRequest struct {
	ctx context.Context
	ApiService *KaspaAddressesAPIService
	kaspaAddress string
}

func (r ApiGetTransactionCountForAddressAddressesKaspaAddressTransactionsCountGetRequest) Execute() (*TransactionCount, *http.Response, error) {
	return r.ApiService.GetTransactionCountForAddressAddressesKaspaAddressTransactionsCountGetExecute(r)
}

/*
GetTransactionCountForAddressAddressesKaspaAddressTransactionsCountGet Get Transaction Count For Address

Count the number of transactions associated with this address

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param kaspaAddress Kaspa address as string e.g. kaspatest:qpqz2vxj23kvh0m73ta2jjn2u4cv4tlufqns2eap8mxyyt0rvrxy6ejkful67
 @return ApiGetTransactionCountForAddressAddressesKaspaAddressTransactionsCountGetRequest
*/
func (a *KaspaAddressesAPIService) GetTransactionCountForAddressAddressesKaspaAddressTransactionsCountGet(ctx context.Context, kaspaAddress string) ApiGetTransactionCountForAddressAddressesKaspaAddressTransactionsCountGetRequest {
	return ApiGetTransactionCountForAddressAddressesKaspaAddressTransactionsCountGetRequest{
		ApiService: a,
		ctx: ctx,
		kaspaAddress: kaspaAddress,
	}
}

// Execute executes the request
//  @return TransactionCount
func (a *KaspaAddressesAPIService) GetTransactionCountForAddressAddressesKaspaAddressTransactionsCountGetExecute(r ApiGetTransactionCountForAddressAddressesKaspaAddressTransactionsCountGetRequest) (*TransactionCount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionCount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaAddressesAPIService.GetTransactionCountForAddressAddressesKaspaAddressTransactionsCountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addresses/{kaspaAddress}/transactions-count"
	localVarPath = strings.Replace(localVarPath, "{"+"kaspaAddress"+"}", url.PathEscape(parameterValueToString(r.kaspaAddress, "kaspaAddress")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUtxosForAddressAddressesKaspaAddressUtxosGetRequest struct {
	ctx context.Context
	ApiService *KaspaAddressesAPIService
	kaspaAddress string
}

func (r ApiGetUtxosForAddressAddressesKaspaAddressUtxosGetRequest) Execute() ([]UtxoResponse, *http.Response, error) {
	return r.ApiService.GetUtxosForAddressAddressesKaspaAddressUtxosGetExecute(r)
}

/*
GetUtxosForAddressAddressesKaspaAddressUtxosGet Get Utxos For Address

Lists all open utxo for a given kaspa address

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param kaspaAddress Kaspa address as string e.g. kaspatest:qpqz2vxj23kvh0m73ta2jjn2u4cv4tlufqns2eap8mxyyt0rvrxy6ejkful67
 @return ApiGetUtxosForAddressAddressesKaspaAddressUtxosGetRequest
*/
func (a *KaspaAddressesAPIService) GetUtxosForAddressAddressesKaspaAddressUtxosGet(ctx context.Context, kaspaAddress string) ApiGetUtxosForAddressAddressesKaspaAddressUtxosGetRequest {
	return ApiGetUtxosForAddressAddressesKaspaAddressUtxosGetRequest{
		ApiService: a,
		ctx: ctx,
		kaspaAddress: kaspaAddress,
	}
}

// Execute executes the request
//  @return []UtxoResponse
func (a *KaspaAddressesAPIService) GetUtxosForAddressAddressesKaspaAddressUtxosGetExecute(r ApiGetUtxosForAddressAddressesKaspaAddressUtxosGetRequest) ([]UtxoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UtxoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaAddressesAPIService.GetUtxosForAddressAddressesKaspaAddressUtxosGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addresses/{kaspaAddress}/utxos"
	localVarPath = strings.Replace(localVarPath, "{"+"kaspaAddress"+"}", url.PathEscape(parameterValueToString(r.kaspaAddress, "kaspaAddress")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUtxosForAddressesAddressesUtxosPostRequest struct {
	ctx context.Context
	ApiService *KaspaAddressesAPIService
	utxoRequest *UtxoRequest
}

func (r ApiGetUtxosForAddressesAddressesUtxosPostRequest) UtxoRequest(utxoRequest UtxoRequest) ApiGetUtxosForAddressesAddressesUtxosPostRequest {
	r.utxoRequest = &utxoRequest
	return r
}

func (r ApiGetUtxosForAddressesAddressesUtxosPostRequest) Execute() ([]UtxoResponse, *http.Response, error) {
	return r.ApiService.GetUtxosForAddressesAddressesUtxosPostExecute(r)
}

/*
GetUtxosForAddressesAddressesUtxosPost Get Utxos For Addresses

Lists all open utxo for a given kaspa address

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUtxosForAddressesAddressesUtxosPostRequest
*/
func (a *KaspaAddressesAPIService) GetUtxosForAddressesAddressesUtxosPost(ctx context.Context) ApiGetUtxosForAddressesAddressesUtxosPostRequest {
	return ApiGetUtxosForAddressesAddressesUtxosPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []UtxoResponse
func (a *KaspaAddressesAPIService) GetUtxosForAddressesAddressesUtxosPostExecute(r ApiGetUtxosForAddressesAddressesUtxosPostRequest) ([]UtxoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []UtxoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaAddressesAPIService.GetUtxosForAddressesAddressesUtxosPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/addresses/utxos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.utxoRequest == nil {
		return localVarReturnValue, nil, reportError("utxoRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.utxoRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
