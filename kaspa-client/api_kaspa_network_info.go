/*
Kaspa REST-API server

This server is to communicate with kaspa network via REST-API

API version: tbd
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// KaspaNetworkInfoAPIService KaspaNetworkInfoAPI service
type KaspaNetworkInfoAPIService service

type ApiGetBlockdagInfoBlockdagGetRequest struct {
	ctx context.Context
	ApiService *KaspaNetworkInfoAPIService
}

func (r ApiGetBlockdagInfoBlockdagGetRequest) Execute() (*EndpointsGetBlockdagBlockdagResponse, *http.Response, error) {
	return r.ApiService.GetBlockdagInfoBlockdagGetExecute(r)
}

/*
GetBlockdagInfoBlockdagGet Get Blockdag

Get some global Kaspa BlockDAG information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBlockdagInfoBlockdagGetRequest
*/
func (a *KaspaNetworkInfoAPIService) GetBlockdagInfoBlockdagGet(ctx context.Context) ApiGetBlockdagInfoBlockdagGetRequest {
	return ApiGetBlockdagInfoBlockdagGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EndpointsGetBlockdagBlockdagResponse
func (a *KaspaNetworkInfoAPIService) GetBlockdagInfoBlockdagGetExecute(r ApiGetBlockdagInfoBlockdagGetRequest) (*EndpointsGetBlockdagBlockdagResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EndpointsGetBlockdagBlockdagResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaNetworkInfoAPIService.GetBlockdagInfoBlockdagGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/info/blockdag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlockrewardInfoBlockrewardGetRequest struct {
	ctx context.Context
	ApiService *KaspaNetworkInfoAPIService
	stringOnly *bool
}

func (r ApiGetBlockrewardInfoBlockrewardGetRequest) StringOnly(stringOnly bool) ApiGetBlockrewardInfoBlockrewardGetRequest {
	r.stringOnly = &stringOnly
	return r
}

func (r ApiGetBlockrewardInfoBlockrewardGetRequest) Execute() (*ResponseGetBlockrewardInfoBlockrewardGet, *http.Response, error) {
	return r.ApiService.GetBlockrewardInfoBlockrewardGetExecute(r)
}

/*
GetBlockrewardInfoBlockrewardGet Get Blockreward

Returns the current blockreward in KAS/block

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBlockrewardInfoBlockrewardGetRequest
*/
func (a *KaspaNetworkInfoAPIService) GetBlockrewardInfoBlockrewardGet(ctx context.Context) ApiGetBlockrewardInfoBlockrewardGetRequest {
	return ApiGetBlockrewardInfoBlockrewardGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResponseGetBlockrewardInfoBlockrewardGet
func (a *KaspaNetworkInfoAPIService) GetBlockrewardInfoBlockrewardGetExecute(r ApiGetBlockrewardInfoBlockrewardGetRequest) (*ResponseGetBlockrewardInfoBlockrewardGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseGetBlockrewardInfoBlockrewardGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaNetworkInfoAPIService.GetBlockrewardInfoBlockrewardGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/info/blockreward"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.stringOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stringOnly", r.stringOnly, "form", "")
	} else {
		var defaultValue bool = false
		r.stringOnly = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCirculatingCoinsInfoCoinsupplyCirculatingGetRequest struct {
	ctx context.Context
	ApiService *KaspaNetworkInfoAPIService
	inBillion *bool
}

func (r ApiGetCirculatingCoinsInfoCoinsupplyCirculatingGetRequest) InBillion(inBillion bool) ApiGetCirculatingCoinsInfoCoinsupplyCirculatingGetRequest {
	r.inBillion = &inBillion
	return r
}

func (r ApiGetCirculatingCoinsInfoCoinsupplyCirculatingGetRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetCirculatingCoinsInfoCoinsupplyCirculatingGetExecute(r)
}

/*
GetCirculatingCoinsInfoCoinsupplyCirculatingGet Get Circulating Coins

Get circulating amount of $KAS token as numerical value

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCirculatingCoinsInfoCoinsupplyCirculatingGetRequest
*/
func (a *KaspaNetworkInfoAPIService) GetCirculatingCoinsInfoCoinsupplyCirculatingGet(ctx context.Context) ApiGetCirculatingCoinsInfoCoinsupplyCirculatingGetRequest {
	return ApiGetCirculatingCoinsInfoCoinsupplyCirculatingGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *KaspaNetworkInfoAPIService) GetCirculatingCoinsInfoCoinsupplyCirculatingGetExecute(r ApiGetCirculatingCoinsInfoCoinsupplyCirculatingGetRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaNetworkInfoAPIService.GetCirculatingCoinsInfoCoinsupplyCirculatingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/info/coinsupply/circulating"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.inBillion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "in_billion", r.inBillion, "form", "")
	} else {
		var defaultValue bool = false
		r.inBillion = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCoinsupplyInfoCoinsupplyGetRequest struct {
	ctx context.Context
	ApiService *KaspaNetworkInfoAPIService
}

func (r ApiGetCoinsupplyInfoCoinsupplyGetRequest) Execute() (*CoinSupplyResponse, *http.Response, error) {
	return r.ApiService.GetCoinsupplyInfoCoinsupplyGetExecute(r)
}

/*
GetCoinsupplyInfoCoinsupplyGet Get Coinsupply

Get $KAS coin supply information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCoinsupplyInfoCoinsupplyGetRequest
*/
func (a *KaspaNetworkInfoAPIService) GetCoinsupplyInfoCoinsupplyGet(ctx context.Context) ApiGetCoinsupplyInfoCoinsupplyGetRequest {
	return ApiGetCoinsupplyInfoCoinsupplyGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CoinSupplyResponse
func (a *KaspaNetworkInfoAPIService) GetCoinsupplyInfoCoinsupplyGetExecute(r ApiGetCoinsupplyInfoCoinsupplyGetRequest) (*CoinSupplyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CoinSupplyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaNetworkInfoAPIService.GetCoinsupplyInfoCoinsupplyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/info/coinsupply"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFeeEstimateInfoFeeEstimateGetRequest struct {
	ctx context.Context
	ApiService *KaspaNetworkInfoAPIService
}

func (r ApiGetFeeEstimateInfoFeeEstimateGetRequest) Execute() (*FeeEstimateResponse, *http.Response, error) {
	return r.ApiService.GetFeeEstimateInfoFeeEstimateGetExecute(r)
}

/*
GetFeeEstimateInfoFeeEstimateGet Get Fee Estimate

Get fee estimate from Kaspad.

For all buckets, feerate values represent fee/mass of a transaction in `sompi/gram` units.<br>
Given a feerate value recommendation, calculate the required fee by
taking the transaction mass and multiplying it by feerate: `fee = feerate * mass(tx)`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetFeeEstimateInfoFeeEstimateGetRequest
*/
func (a *KaspaNetworkInfoAPIService) GetFeeEstimateInfoFeeEstimateGet(ctx context.Context) ApiGetFeeEstimateInfoFeeEstimateGetRequest {
	return ApiGetFeeEstimateInfoFeeEstimateGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FeeEstimateResponse
func (a *KaspaNetworkInfoAPIService) GetFeeEstimateInfoFeeEstimateGetExecute(r ApiGetFeeEstimateInfoFeeEstimateGetRequest) (*FeeEstimateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FeeEstimateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaNetworkInfoAPIService.GetFeeEstimateInfoFeeEstimateGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/info/fee-estimate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHalvingInfoHalvingGetRequest struct {
	ctx context.Context
	ApiService *KaspaNetworkInfoAPIService
	field *string
}

func (r ApiGetHalvingInfoHalvingGetRequest) Field(field string) ApiGetHalvingInfoHalvingGetRequest {
	r.field = &field
	return r
}

func (r ApiGetHalvingInfoHalvingGetRequest) Execute() (*ResponseGetHalvingInfoHalvingGet, *http.Response, error) {
	return r.ApiService.GetHalvingInfoHalvingGetExecute(r)
}

/*
GetHalvingInfoHalvingGet Get Halving

Returns information about chromatic halving

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetHalvingInfoHalvingGetRequest
*/
func (a *KaspaNetworkInfoAPIService) GetHalvingInfoHalvingGet(ctx context.Context) ApiGetHalvingInfoHalvingGetRequest {
	return ApiGetHalvingInfoHalvingGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResponseGetHalvingInfoHalvingGet
func (a *KaspaNetworkInfoAPIService) GetHalvingInfoHalvingGetExecute(r ApiGetHalvingInfoHalvingGetRequest) (*ResponseGetHalvingInfoHalvingGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseGetHalvingInfoHalvingGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaNetworkInfoAPIService.GetHalvingInfoHalvingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/info/halving"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.field != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "field", r.field, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHashrateInfoHashrateGetRequest struct {
	ctx context.Context
	ApiService *KaspaNetworkInfoAPIService
	stringOnly *bool
}

func (r ApiGetHashrateInfoHashrateGetRequest) StringOnly(stringOnly bool) ApiGetHashrateInfoHashrateGetRequest {
	r.stringOnly = &stringOnly
	return r
}

func (r ApiGetHashrateInfoHashrateGetRequest) Execute() (*ResponseGetHashrateInfoHashrateGet, *http.Response, error) {
	return r.ApiService.GetHashrateInfoHashrateGetExecute(r)
}

/*
GetHashrateInfoHashrateGet Get Hashrate

Returns the current hashrate for Kaspa network in TH/s.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetHashrateInfoHashrateGetRequest
*/
func (a *KaspaNetworkInfoAPIService) GetHashrateInfoHashrateGet(ctx context.Context) ApiGetHashrateInfoHashrateGetRequest {
	return ApiGetHashrateInfoHashrateGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResponseGetHashrateInfoHashrateGet
func (a *KaspaNetworkInfoAPIService) GetHashrateInfoHashrateGetExecute(r ApiGetHashrateInfoHashrateGetRequest) (*ResponseGetHashrateInfoHashrateGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseGetHashrateInfoHashrateGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaNetworkInfoAPIService.GetHashrateInfoHashrateGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/info/hashrate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.stringOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stringOnly", r.stringOnly, "form", "")
	} else {
		var defaultValue bool = false
		r.stringOnly = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetKaspadInfoInfoKaspadGetRequest struct {
	ctx context.Context
	ApiService *KaspaNetworkInfoAPIService
}

func (r ApiGetKaspadInfoInfoKaspadGetRequest) Execute() (*KaspadInfoResponse, *http.Response, error) {
	return r.ApiService.GetKaspadInfoInfoKaspadGetExecute(r)
}

/*
GetKaspadInfoInfoKaspadGet Get Kaspad Info

Get some information for kaspad instance, which is currently connected.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetKaspadInfoInfoKaspadGetRequest
*/
func (a *KaspaNetworkInfoAPIService) GetKaspadInfoInfoKaspadGet(ctx context.Context) ApiGetKaspadInfoInfoKaspadGetRequest {
	return ApiGetKaspadInfoInfoKaspadGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return KaspadInfoResponse
func (a *KaspaNetworkInfoAPIService) GetKaspadInfoInfoKaspadGetExecute(r ApiGetKaspadInfoInfoKaspadGetRequest) (*KaspadInfoResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KaspadInfoResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaNetworkInfoAPIService.GetKaspadInfoInfoKaspadGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/info/kaspad"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMarketcapInfoMarketcapGetRequest struct {
	ctx context.Context
	ApiService *KaspaNetworkInfoAPIService
	stringOnly *bool
}

func (r ApiGetMarketcapInfoMarketcapGetRequest) StringOnly(stringOnly bool) ApiGetMarketcapInfoMarketcapGetRequest {
	r.stringOnly = &stringOnly
	return r
}

func (r ApiGetMarketcapInfoMarketcapGetRequest) Execute() (*ResponseGetMarketcapInfoMarketcapGet, *http.Response, error) {
	return r.ApiService.GetMarketcapInfoMarketcapGetExecute(r)
}

/*
GetMarketcapInfoMarketcapGet Get Marketcap

Get $KAS price and market cap. Price info is from coingecko.com

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMarketcapInfoMarketcapGetRequest
*/
func (a *KaspaNetworkInfoAPIService) GetMarketcapInfoMarketcapGet(ctx context.Context) ApiGetMarketcapInfoMarketcapGetRequest {
	return ApiGetMarketcapInfoMarketcapGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResponseGetMarketcapInfoMarketcapGet
func (a *KaspaNetworkInfoAPIService) GetMarketcapInfoMarketcapGetExecute(r ApiGetMarketcapInfoMarketcapGetRequest) (*ResponseGetMarketcapInfoMarketcapGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseGetMarketcapInfoMarketcapGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaNetworkInfoAPIService.GetMarketcapInfoMarketcapGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/info/marketcap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.stringOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stringOnly", r.stringOnly, "form", "")
	} else {
		var defaultValue bool = false
		r.stringOnly = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMaxHashrateInfoHashrateMaxGetRequest struct {
	ctx context.Context
	ApiService *KaspaNetworkInfoAPIService
}

func (r ApiGetMaxHashrateInfoHashrateMaxGetRequest) Execute() (*MaxHashrateResponse, *http.Response, error) {
	return r.ApiService.GetMaxHashrateInfoHashrateMaxGetExecute(r)
}

/*
GetMaxHashrateInfoHashrateMaxGet Get Max Hashrate

Returns the current hashrate for Kaspa network in TH/s.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMaxHashrateInfoHashrateMaxGetRequest
*/
func (a *KaspaNetworkInfoAPIService) GetMaxHashrateInfoHashrateMaxGet(ctx context.Context) ApiGetMaxHashrateInfoHashrateMaxGetRequest {
	return ApiGetMaxHashrateInfoHashrateMaxGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MaxHashrateResponse
func (a *KaspaNetworkInfoAPIService) GetMaxHashrateInfoHashrateMaxGetExecute(r ApiGetMaxHashrateInfoHashrateMaxGetRequest) (*MaxHashrateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MaxHashrateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaNetworkInfoAPIService.GetMaxHashrateInfoHashrateMaxGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/info/hashrate/max"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetNetworkInfoNetworkGetRequest struct {
	ctx context.Context
	ApiService *KaspaNetworkInfoAPIService
}

func (r ApiGetNetworkInfoNetworkGetRequest) Execute() (*NetworkResponse, *http.Response, error) {
	return r.ApiService.GetNetworkInfoNetworkGetExecute(r)
}

/*
GetNetworkInfoNetworkGet Get Network

Get some global kaspa network information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetNetworkInfoNetworkGetRequest
*/
func (a *KaspaNetworkInfoAPIService) GetNetworkInfoNetworkGet(ctx context.Context) ApiGetNetworkInfoNetworkGetRequest {
	return ApiGetNetworkInfoNetworkGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NetworkResponse
func (a *KaspaNetworkInfoAPIService) GetNetworkInfoNetworkGetExecute(r ApiGetNetworkInfoNetworkGetRequest) (*NetworkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NetworkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaNetworkInfoAPIService.GetNetworkInfoNetworkGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/info/network"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPriceInfoPriceGetRequest struct {
	ctx context.Context
	ApiService *KaspaNetworkInfoAPIService
	stringOnly *bool
}

func (r ApiGetPriceInfoPriceGetRequest) StringOnly(stringOnly bool) ApiGetPriceInfoPriceGetRequest {
	r.stringOnly = &stringOnly
	return r
}

func (r ApiGetPriceInfoPriceGetRequest) Execute() (*ResponseGetPriceInfoPriceGet, *http.Response, error) {
	return r.ApiService.GetPriceInfoPriceGetExecute(r)
}

/*
GetPriceInfoPriceGet Get Price

Returns the current price for Kaspa in USD.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPriceInfoPriceGetRequest
*/
func (a *KaspaNetworkInfoAPIService) GetPriceInfoPriceGet(ctx context.Context) ApiGetPriceInfoPriceGetRequest {
	return ApiGetPriceInfoPriceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ResponseGetPriceInfoPriceGet
func (a *KaspaNetworkInfoAPIService) GetPriceInfoPriceGetExecute(r ApiGetPriceInfoPriceGetRequest) (*ResponseGetPriceInfoPriceGet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseGetPriceInfoPriceGet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaNetworkInfoAPIService.GetPriceInfoPriceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/info/price"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.stringOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stringOnly", r.stringOnly, "form", "")
	} else {
		var defaultValue bool = false
		r.stringOnly = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTotalCoinsInfoCoinsupplyTotalGetRequest struct {
	ctx context.Context
	ApiService *KaspaNetworkInfoAPIService
}

func (r ApiGetTotalCoinsInfoCoinsupplyTotalGetRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetTotalCoinsInfoCoinsupplyTotalGetExecute(r)
}

/*
GetTotalCoinsInfoCoinsupplyTotalGet Get Total Coins

Get total amount of $KAS token as numerical value

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTotalCoinsInfoCoinsupplyTotalGetRequest
*/
func (a *KaspaNetworkInfoAPIService) GetTotalCoinsInfoCoinsupplyTotalGet(ctx context.Context) ApiGetTotalCoinsInfoCoinsupplyTotalGetRequest {
	return ApiGetTotalCoinsInfoCoinsupplyTotalGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *KaspaNetworkInfoAPIService) GetTotalCoinsInfoCoinsupplyTotalGetExecute(r ApiGetTotalCoinsInfoCoinsupplyTotalGetRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaNetworkInfoAPIService.GetTotalCoinsInfoCoinsupplyTotalGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/info/coinsupply/total"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVirtualSelectedParentBlueScoreInfoVirtualChainBlueScoreGetRequest struct {
	ctx context.Context
	ApiService *KaspaNetworkInfoAPIService
}

func (r ApiGetVirtualSelectedParentBlueScoreInfoVirtualChainBlueScoreGetRequest) Execute() (*EndpointsGetVirtualChainBlueScoreBlockdagResponse, *http.Response, error) {
	return r.ApiService.GetVirtualSelectedParentBlueScoreInfoVirtualChainBlueScoreGetExecute(r)
}

/*
GetVirtualSelectedParentBlueScoreInfoVirtualChainBlueScoreGet Get Virtual Selected Parent Blue Score

Returns the blue score of virtual selected parent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetVirtualSelectedParentBlueScoreInfoVirtualChainBlueScoreGetRequest
*/
func (a *KaspaNetworkInfoAPIService) GetVirtualSelectedParentBlueScoreInfoVirtualChainBlueScoreGet(ctx context.Context) ApiGetVirtualSelectedParentBlueScoreInfoVirtualChainBlueScoreGetRequest {
	return ApiGetVirtualSelectedParentBlueScoreInfoVirtualChainBlueScoreGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EndpointsGetVirtualChainBlueScoreBlockdagResponse
func (a *KaspaNetworkInfoAPIService) GetVirtualSelectedParentBlueScoreInfoVirtualChainBlueScoreGetExecute(r ApiGetVirtualSelectedParentBlueScoreInfoVirtualChainBlueScoreGetRequest) (*EndpointsGetVirtualChainBlueScoreBlockdagResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EndpointsGetVirtualChainBlueScoreBlockdagResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaNetworkInfoAPIService.GetVirtualSelectedParentBlueScoreInfoVirtualChainBlueScoreGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/info/virtual-chain-blue-score"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHealthStateInfoHealthGetRequest struct {
	ctx context.Context
	ApiService *KaspaNetworkInfoAPIService
}

func (r ApiHealthStateInfoHealthGetRequest) Execute() (*HealthResponse, *http.Response, error) {
	return r.ApiService.HealthStateInfoHealthGetExecute(r)
}

/*
HealthStateInfoHealthGet Health State

Checks node and database health by comparing blue score and sync status.
Returns health details or 503 if the database lags by ~10min or no nodes are synced.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHealthStateInfoHealthGetRequest
*/
func (a *KaspaNetworkInfoAPIService) HealthStateInfoHealthGet(ctx context.Context) ApiHealthStateInfoHealthGetRequest {
	return ApiHealthStateInfoHealthGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HealthResponse
func (a *KaspaNetworkInfoAPIService) HealthStateInfoHealthGetExecute(r ApiHealthStateInfoHealthGetRequest) (*HealthResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HealthResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaNetworkInfoAPIService.HealthStateInfoHealthGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/info/health"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
