/*
Kaspa REST-API server

This server is to communicate with kaspa network via REST-API

API version: tbd
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// KaspaTransactionsAPIService KaspaTransactionsAPI service
type KaspaTransactionsAPIService service

type ApiCalculateTransactionMassTransactionsMassPostRequest struct {
	ctx context.Context
	ApiService *KaspaTransactionsAPIService
	submitTxModel *SubmitTxModel
}

func (r ApiCalculateTransactionMassTransactionsMassPostRequest) SubmitTxModel(submitTxModel SubmitTxModel) ApiCalculateTransactionMassTransactionsMassPostRequest {
	r.submitTxModel = &submitTxModel
	return r
}

func (r ApiCalculateTransactionMassTransactionsMassPostRequest) Execute() (*TxMass, *http.Response, error) {
	return r.ApiService.CalculateTransactionMassTransactionsMassPostExecute(r)
}

/*
CalculateTransactionMassTransactionsMassPost Calculate Transaction Mass

This function calculates and returns the mass of a transaction, which is essential for determining the minimum fee. The mass calculation takes into account the storage mass as defined in KIP-0009.

Note: Be aware that if the transaction has a very low output amount or a high number of outputs, the mass can become significantly large.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCalculateTransactionMassTransactionsMassPostRequest
*/
func (a *KaspaTransactionsAPIService) CalculateTransactionMassTransactionsMassPost(ctx context.Context) ApiCalculateTransactionMassTransactionsMassPostRequest {
	return ApiCalculateTransactionMassTransactionsMassPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TxMass
func (a *KaspaTransactionsAPIService) CalculateTransactionMassTransactionsMassPostExecute(r ApiCalculateTransactionMassTransactionsMassPostRequest) (*TxMass, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TxMass
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaTransactionsAPIService.CalculateTransactionMassTransactionsMassPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/mass"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.submitTxModel == nil {
		return localVarReturnValue, nil, reportError("submitTxModel is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.submitTxModel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTransactionTransactionsTransactionIdGetRequest struct {
	ctx context.Context
	ApiService *KaspaTransactionsAPIService
	transactionId string
	blockHash *string
	inputs *bool
	outputs *bool
	resolvePreviousOutpoints *EndpointsGetTransactionsPreviousOutpointLookupMode
}

// Specify a containing block (if known) for faster lookup
func (r ApiGetTransactionTransactionsTransactionIdGetRequest) BlockHash(blockHash string) ApiGetTransactionTransactionsTransactionIdGetRequest {
	r.blockHash = &blockHash
	return r
}

func (r ApiGetTransactionTransactionsTransactionIdGetRequest) Inputs(inputs bool) ApiGetTransactionTransactionsTransactionIdGetRequest {
	r.inputs = &inputs
	return r
}

func (r ApiGetTransactionTransactionsTransactionIdGetRequest) Outputs(outputs bool) ApiGetTransactionTransactionsTransactionIdGetRequest {
	r.outputs = &outputs
	return r
}

// Use this parameter if you want to fetch the TransactionInput previous outpoint details. Light fetches only the address and amount. Full fetches the whole TransactionOutput and adds it into each TxInput.
func (r ApiGetTransactionTransactionsTransactionIdGetRequest) ResolvePreviousOutpoints(resolvePreviousOutpoints EndpointsGetTransactionsPreviousOutpointLookupMode) ApiGetTransactionTransactionsTransactionIdGetRequest {
	r.resolvePreviousOutpoints = &resolvePreviousOutpoints
	return r
}

func (r ApiGetTransactionTransactionsTransactionIdGetRequest) Execute() (*TxModel, *http.Response, error) {
	return r.ApiService.GetTransactionTransactionsTransactionIdGetExecute(r)
}

/*
GetTransactionTransactionsTransactionIdGet Get Transaction

Get details for a given transaction id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId
 @return ApiGetTransactionTransactionsTransactionIdGetRequest
*/
func (a *KaspaTransactionsAPIService) GetTransactionTransactionsTransactionIdGet(ctx context.Context, transactionId string) ApiGetTransactionTransactionsTransactionIdGetRequest {
	return ApiGetTransactionTransactionsTransactionIdGetRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
	}
}

// Execute executes the request
//  @return TxModel
func (a *KaspaTransactionsAPIService) GetTransactionTransactionsTransactionIdGetExecute(r ApiGetTransactionTransactionsTransactionIdGetRequest) (*TxModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TxModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaTransactionsAPIService.GetTransactionTransactionsTransactionIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/{transactionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"transactionId"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blockHash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blockHash", r.blockHash, "form", "")
	}
	if r.inputs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "inputs", r.inputs, "form", "")
	} else {
		var defaultValue bool = true
		r.inputs = &defaultValue
	}
	if r.outputs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "outputs", r.outputs, "form", "")
	} else {
		var defaultValue bool = true
		r.outputs = &defaultValue
	}
	if r.resolvePreviousOutpoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resolve_previous_outpoints", r.resolvePreviousOutpoints, "form", "")
	} else {
		var defaultValue EndpointsGetTransactionsPreviousOutpointLookupMode = "no"
		r.resolvePreviousOutpoints = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchForTransactionsTransactionsSearchPostRequest struct {
	ctx context.Context
	ApiService *KaspaTransactionsAPIService
	txSearch *TxSearch
	fields *string
	resolvePreviousOutpoints *EndpointsGetTransactionsPreviousOutpointLookupMode
}

func (r ApiSearchForTransactionsTransactionsSearchPostRequest) TxSearch(txSearch TxSearch) ApiSearchForTransactionsTransactionsSearchPostRequest {
	r.txSearch = &txSearch
	return r
}

func (r ApiSearchForTransactionsTransactionsSearchPostRequest) Fields(fields string) ApiSearchForTransactionsTransactionsSearchPostRequest {
	r.fields = &fields
	return r
}

// Use this parameter if you want to fetch the TransactionInput previous outpoint details. Light fetches only the address and amount. Full fetches the whole TransactionOutput and adds it into each TxInput.
func (r ApiSearchForTransactionsTransactionsSearchPostRequest) ResolvePreviousOutpoints(resolvePreviousOutpoints EndpointsGetTransactionsPreviousOutpointLookupMode) ApiSearchForTransactionsTransactionsSearchPostRequest {
	r.resolvePreviousOutpoints = &resolvePreviousOutpoints
	return r
}

func (r ApiSearchForTransactionsTransactionsSearchPostRequest) Execute() ([]TxModel, *http.Response, error) {
	return r.ApiService.SearchForTransactionsTransactionsSearchPostExecute(r)
}

/*
SearchForTransactionsTransactionsSearchPost Search For Transactions

Search for transactions by transaction_ids or blue_score

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchForTransactionsTransactionsSearchPostRequest
*/
func (a *KaspaTransactionsAPIService) SearchForTransactionsTransactionsSearchPost(ctx context.Context) ApiSearchForTransactionsTransactionsSearchPostRequest {
	return ApiSearchForTransactionsTransactionsSearchPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TxModel
func (a *KaspaTransactionsAPIService) SearchForTransactionsTransactionsSearchPostExecute(r ApiSearchForTransactionsTransactionsSearchPostRequest) ([]TxModel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TxModel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaTransactionsAPIService.SearchForTransactionsTransactionsSearchPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.txSearch == nil {
		return localVarReturnValue, nil, reportError("txSearch is required and must be specified")
	}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "form", "")
	} else {
		var defaultValue string = ""
		r.fields = &defaultValue
	}
	if r.resolvePreviousOutpoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resolve_previous_outpoints", r.resolvePreviousOutpoints, "form", "")
	} else {
		var defaultValue EndpointsGetTransactionsPreviousOutpointLookupMode = "no"
		r.resolvePreviousOutpoints = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.txSearch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitANewTransactionTransactionsPostRequest struct {
	ctx context.Context
	ApiService *KaspaTransactionsAPIService
	submitTransactionRequest *SubmitTransactionRequest
	replaceByFee *bool
}

func (r ApiSubmitANewTransactionTransactionsPostRequest) SubmitTransactionRequest(submitTransactionRequest SubmitTransactionRequest) ApiSubmitANewTransactionTransactionsPostRequest {
	r.submitTransactionRequest = &submitTransactionRequest
	return r
}

// Replace an existing transaction in the mempool
func (r ApiSubmitANewTransactionTransactionsPostRequest) ReplaceByFee(replaceByFee bool) ApiSubmitANewTransactionTransactionsPostRequest {
	r.replaceByFee = &replaceByFee
	return r
}

func (r ApiSubmitANewTransactionTransactionsPostRequest) Execute() (*SubmitTransactionResponse, *http.Response, error) {
	return r.ApiService.SubmitANewTransactionTransactionsPostExecute(r)
}

/*
SubmitANewTransactionTransactionsPost Submit A New Transaction

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubmitANewTransactionTransactionsPostRequest
*/
func (a *KaspaTransactionsAPIService) SubmitANewTransactionTransactionsPost(ctx context.Context) ApiSubmitANewTransactionTransactionsPostRequest {
	return ApiSubmitANewTransactionTransactionsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubmitTransactionResponse
func (a *KaspaTransactionsAPIService) SubmitANewTransactionTransactionsPostExecute(r ApiSubmitANewTransactionTransactionsPostRequest) (*SubmitTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubmitTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "KaspaTransactionsAPIService.SubmitANewTransactionTransactionsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transactions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.submitTransactionRequest == nil {
		return localVarReturnValue, nil, reportError("submitTransactionRequest is required and must be specified")
	}

	if r.replaceByFee != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "replaceByFee", r.replaceByFee, "form", "")
	} else {
		var defaultValue bool = false
		r.replaceByFee = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.submitTransactionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v SubmitTransactionResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
